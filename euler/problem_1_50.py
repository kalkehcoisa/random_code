from euler import *

#If we list all the natural numbers below 10 that are multiples of 3 or 5,
#we get 3, 5, 6 and 9. The sum of these multiples is 23.
#Find the sum of all the multiples of 3 or 5 below 1000.
def problem_1():
    sum = 0
    for p in range(1, 1000):
        if p % 3 == 0:
            sum = sum + p
        elif p % 5 == 0:
            sum = sum + p
    print sum

#Each new term in the Fibonacci sequence is generated by adding the previous
#two terms. By starting with 1 and 2, the first 10 terms will be:
#1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#By considering the terms in the Fibonacci sequence whose values do not exceed
#four million, find the sum of the even-valued terms.
def problem_2():
    t = 1
    s = 1
    sum = 0

    while( s < 4000000 ):
        t = t + s
        s = t + s
        if s % 2 == 0:
            sum = sum + s
        if t % 2 == 0:
            sum = sum + t
    print sum

#The prime factors of 13195 are 5, 7, 13 and 29.
#What is the largest prime factor of the number 600851475143 ?
def problem_3():
    print max_prime_factor(600851475143)


#A palindromic number reads the same both ways. The largest palindrome made
#from the product of two 2-digit numbers is 9009 = 91 99.
#Find the largest palindrome made from the product of two 3-digit numbers.
def max_divisor_3(number):
    import math
    max = math.sqrt(number)

    factor = 1
    for p in range(99, int(math.ceil(max)) ):
        if( number % p == 0 ):
            factor = p
    if number / factor > 999:
        return 0
    else:
        return factor
def problem_4():
    min = 100 * 100
    p = 999 * 999
    while p >= min:
        if str(p) == str(p)[::-1]:
            #print p
            if max_divisor_3(p) > 1:
                print ':: %d' % p
                return
        p = p - 1
    return

#2520 is the smallest number that can be divided by each of the numbers from
#1 to 10 without any remainder.
#What is the smallest positive number that is evenly divisible by all of
#the numbers from 1 to 20?
def problem_5():
    import math
    list = {}

    for p in range(2, 20):
        aux = prime_factors(p)
        if len(aux) == 0:
            list[str(p)] = 1
        else:
            for p in aux:
                if str(p) in list:
                    if list[str(p)] < aux[str(p)]:
                        list[str(p)] = aux[str(p)]
                else:
                    list[str(p)] = aux[str(p)]
    mult = 1
    for p in list.keys():
        mult = mult*math.pow(int(p), list[p])
    print mult

#The sum of the squares of the first ten natural numbers is,
#12 + 22 + ... + 102 = 385
#The square of the sum of the first ten natural numbers is,
#(1 + 2 + ... + 10)2 = 552 = 3025
#Hence the difference between the sum of the squares of the first ten natural
#numbers and the square of the sum is 3025  385 = 2640.
#Find the difference between the sum of the squares of the first one hundred
#natural numbers and the square of the sum.
def problem_6():
    square_sum = 0
    sum_square = 0
    for p in range(1, 101):
        square_sum = square_sum + p*p
        sum_square = sum_square + p
    sum_square = sum_square * sum_square
    print '%d' % (sum_square - square_sum)

#By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can
#see that the 6th prime is 13.
#What is the 10 001st prime number?
def problem_7():
    cont = 1
    number = 3
    prime = 0
    while(cont < 10001):
        if is_prime(number):
            cont += 1
            prime = number
        number += 2
    print prime

#Find the greatest product of five consecutive digits in the 1000-digit number.
def problem_8():
    string =  '73167176531330624919225119674426574742355349194934'
    string += '96983520312774506326239578318016984801869478851843'
    string += '85861560789112949495459501737958331952853208805511'
    string += '12540698747158523863050715693290963295227443043557'
    string += '66896648950445244523161731856403098711121722383113'
    string += '62229893423380308135336276614282806444486645238749'
    string += '30358907296290491560440772390713810515859307960866'
    string += '70172427121883998797908792274921901699720888093776'
    string += '65727333001053367881220235421809751254540594752243'
    string += '52584907711670556013604839586446706324415722155397'
    string += '53697817977846174064955149290862569321978468622482'
    string += '83972241375657056057490261407972968652414535100474'
    string += '82166370484403199890008895243450658541227588666881'
    string += '16427171479924442928230863465674813919123162824586'
    string += '17866458359124566529476545682848912883142607690042'
    string += '24219022671055626321111109370544217506941658960408'
    string += '07198403850962455444362981230987879927244284909188'
    string += '84580156166097919133875499200524063689912560717606'
    string += '05886116467109405077541002256983155200055935729725'
    string += '7163626956188267042825248360082325753042075296345'

    i = 0
    length = len(string)
    answer = 0
    while i + 4 < length:
        product = 1
        for p in range(0, 5):
            product *= int(string[i+p])
        if product > answer:
            answer = product
        i += 1
    print answer

#A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
#a2 + b2 = c2
#For example, 32 + 42 = 9 + 16 = 25 = 52.
#There exists exactly one Pythagorean triplet for which a + b + c = 1000.
#Find the product abc
def problem_9():
    import math

    for a in range(1, 1000):
        for b in range(a+1, 1000):
            c = math.sqrt(a*a + b*b)
            if is_rational(c):
                if a + b + c == 1000:
                    print ( a, b, c)
                    print int( a*b*c )


#The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
#Find the sum of all the primes below two million.
def problem_10():
    sum = 0
    for p in range(1, 2000000):
        if is_prime(p):
           sum += p
    print sum



def right_line(array, x, y):
    try:
        aux = [array[x][y], array[x][y+1], array[x][y+2], array[x][y+3]]
        result = 1
        for p in aux:
            result *= p
        return result
    except:
        return None

def downdia_line(array, x, y):
    try:
        aux = [array[x][y], array[x+1][y+1], array[x+2][y+2], array[x+3][y+3]]
        result = 1
        for p in aux:
            result *= p
        return result
    except:
        return None

def topdia_line(array, x, y):
    try:
        aux = [array[x][y], array[x-1][y+1], array[x-2][y+2], array[x-3][y+3]]
        result = 1
        for p in aux:
            result *= p
        return result
    except:
        return None

#In the 2020 grid below, four numbers along a diagonal line have been marked
#in red.
#What is the greatest product of four adjacent numbers in any direction (up,
#down, left, right, or diagonally) in the 2020 grid?
def problem_11():#array 20x20
    from numpy import array
    aux = []
    aux.append([8, 2, 22, 97, 38, 15, 0, 40, 0, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8])
    aux.append([49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 0])
    aux.append([81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65])
    aux.append([52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91])
    aux.append([22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80])
    aux.append([24, 47, 32, 60, 99, 03, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50])
    aux.append([32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70])
    aux.append([67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21])
    aux.append([24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72])
    aux.append([21, 36, 23, 9, 75, 0, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95])
    aux.append([78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92])
    aux.append([16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57])
    aux.append([86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58])
    aux.append([19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40])
    aux.append([4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66])
    aux.append([88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69])
    aux.append([4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36])
    aux.append([20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16])
    aux.append([20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54])
    aux.append([1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48])
    data = array( aux )
    del aux

    max = 0
    for x in range(0, 20):
        for y in range(0, 20):
            aux = right_line(data, x, y)
            if max < aux:
                max = aux
            aux = downdia_line(data, x, y)
            if max < aux:
                max = aux
            aux = topdia_line(data, x, y)
            if max < aux:
                max = aux
    print max

#The sequence of triangle numbers is generated by adding the natural numbers.
#So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
#ten terms would be:
#1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#Let us list the factors of the first seven triangle numbers:
#1: 1
#3: 1,3
#6: 1,2,3,6
#10: 1,2,5,10
#15: 1,3,5,15
#21: 1,3,7,21
#28: 1,2,4,7,14,28
#We can see that 28 is the first triangle number to have over five divisors.
#What is the value of the first triangle number to have over five hundred divisors?
def problem_12():
    number = 1
    cont = 1
    temp = 0
    number = 1#cont*(cont+1)/2

    while( temp <= 500 ):
        cont += 1
        number += cont
        temp = num_divisors(number)
    print number

#Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
def problem_13():
    from numpy import array
    data = array( [37107287533902102798797998220837590246510135740250,
    46376937677490009712648124896970078050417018260538,
    74324986199524741059474233309513058123726617309629,
    91942213363574161572522430563301811072406154908250,
    23067588207539346171171980310421047513778063246676,
    89261670696623633820136378418383684178734361726757,
    28112879812849979408065481931592621691275889832738,
    44274228917432520321923589422876796487670272189318,
    47451445736001306439091167216856844588711603153276,
    70386486105843025439939619828917593665686757934951,
    62176457141856560629502157223196586755079324193331,
    64906352462741904929101432445813822663347944758178,
    92575867718337217661963751590579239728245598838407,
    58203565325359399008402633568948830189458628227828,
    80181199384826282014278194139940567587151170094390,
    35398664372827112653829987240784473053190104293586,
    86515506006295864861532075273371959191420517255829,
    71693888707715466499115593487603532921714970056938,
    54370070576826684624621495650076471787294438377604,
    53282654108756828443191190634694037855217779295145,
    36123272525000296071075082563815656710885258350721,
    45876576172410976447339110607218265236877223636045,
    17423706905851860660448207621209813287860733969412,
    81142660418086830619328460811191061556940512689692,
    51934325451728388641918047049293215058642563049483,
    62467221648435076201727918039944693004732956340691,
    15732444386908125794514089057706229429197107928209,
    55037687525678773091862540744969844508330393682126,
    18336384825330154686196124348767681297534375946515,
    80386287592878490201521685554828717201219257766954,
    78182833757993103614740356856449095527097864797581,
    16726320100436897842553539920931837441497806860984,
    48403098129077791799088218795327364475675590848030,
    87086987551392711854517078544161852424320693150332,
    59959406895756536782107074926966537676326235447210,
    69793950679652694742597709739166693763042633987085,
    41052684708299085211399427365734116182760315001271,
    65378607361501080857009149939512557028198746004375,
    35829035317434717326932123578154982629742552737307,
    94953759765105305946966067683156574377167401875275,
    88902802571733229619176668713819931811048770190271,
    25267680276078003013678680992525463401061632866526,
    36270218540497705585629946580636237993140746255962,
    24074486908231174977792365466257246923322810917141,
    91430288197103288597806669760892938638285025333403,
    34413065578016127815921815005561868836468420090470,
    23053081172816430487623791969842487255036638784583,
    11487696932154902810424020138335124462181441773470,
    63783299490636259666498587618221225225512486764533,
    67720186971698544312419572409913959008952310058822,
    95548255300263520781532296796249481641953868218774,
    76085327132285723110424803456124867697064507995236,
    37774242535411291684276865538926205024910326572967,
    23701913275725675285653248258265463092207058596522,
    29798860272258331913126375147341994889534765745501,
    18495701454879288984856827726077713721403798879715,
    38298203783031473527721580348144513491373226651381,
    34829543829199918180278916522431027392251122869539,
    40957953066405232632538044100059654939159879593635,
    29746152185502371307642255121183693803580388584903,
    41698116222072977186158236678424689157993532961922,
    62467957194401269043877107275048102390895523597457,
    23189706772547915061505504953922979530901129967519,
    86188088225875314529584099251203829009407770775672,
    11306739708304724483816533873502340845647058077308,
    82959174767140363198008187129011875491310547126581,
    97623331044818386269515456334926366572897563400500,
    42846280183517070527831839425882145521227251250327,
    55121603546981200581762165212827652751691296897789,
    32238195734329339946437501907836945765883352399886,
    75506164965184775180738168837861091527357929701337,
    62177842752192623401942399639168044983993173312731,
    32924185707147349566916674687634660915035914677504,
    99518671430235219628894890102423325116913619626622,
    73267460800591547471830798392868535206946944540724,
    76841822524674417161514036427982273348055556214818,
    97142617910342598647204516893989422179826088076852,
    87783646182799346313767754307809363333018982642090,
    10848802521674670883215120185883543223812876952786,
    71329612474782464538636993009049310363619763878039,
    62184073572399794223406235393808339651327408011116,
    66627891981488087797941876876144230030984490851411,
    60661826293682836764744779239180335110989069790714,
    85786944089552990653640447425576083659976645795096,
    66024396409905389607120198219976047599490197230297,
    64913982680032973156037120041377903785566085089252,
    16730939319872750275468906903707539413042652315011,
    94809377245048795150954100921645863754710598436791,
    78639167021187492431995700641917969777599028300699,
    15368713711936614952811305876380278410754449733078,
    40789923115535562561142322423255033685442488917353,
    44889911501440648020369068063960672322193204149535,
    41503128880339536053299340368006977710650566631954,
    81234880673210146739058568557934581403627822703280,
    82616570773948327592232845941706525094512325230608,
    22918802058777319719839450180888072429661980811197,
    77158542502016545090413245809786882778948721859617,
    72107838435069186155435662884062257473692284509516,
    20849603980134001723930671666823555245252804609722,
    53503534226472524250874054075591789781264330331690] )
    print str( data.sum() )[:10]

def num_collatz(number):
    cont = 0
    while(number > 1):
        cont += 1
        if number % 2 == 0:
            number /= 2
        else:
            number = 3*number + 1
    return cont

def problem_14():
    number = 999999
    result = 0
    length = 0
    aux = 0

    while( number > 1 ):
        aux = num_collatz(number)
        if aux > length:
            result = number
            length = aux
        number -= 1
    print (result, length)

#Starting in the top left corner of a 22 grid, there are 6 routes (without
#backtracking) to the bottom right corner.
#How many routes are there through a 2020 grid?
def problem_15():
    val = 1
    div = 1
    for p in range(1, 21):
        div *= p

    for p in range(21, 41):
        val *= p
    val /= div
    print val

#215 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
#What is the sum of the digits of the number 21000?
def problem_16():
    d1000 = 1
    for p in range(0, 1000):
        d1000 *= 2
    val = d1000
    saida = 0
    while val >= 10:
        saida += val % 10
        val /= 10
    saida += val % 10
    print saida

#If the numbers 1 to 5 are written out in words: one, two, three, four, five,
#then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
#If all the numbers from 1 to 1000 (one thousand) inclusive were written out
#in words, how many letters would be used?
#NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and
#forty-two) contains 23 letters and 115 (one hundred and fifteen) contains
#20 letters. The use of "and" when writing out numbers is in compliance
#with British usage.
def problem_17():
    unit = {1:'one', 2:'two', 3:'three', 4:'four',
            5:'five', 6:'six', 7:'seven', 8:'eight',
            9:'nine'}
    teens = {11:'eleven', 12:'twelve', 13:'thirteen',
             14:'fourteen', 15:'fifteen', 16:'sixteen',
             17:'seventeen', 18: 'eighteen', 19:'nineteen'}
    dec = {1:'ten', 2:'twenty', 3:'thirty',
           4:'forty', 5:'fifty', 6:'sixty',
           7:'seventy', 8:'eighty', 9:'ninety'}
    cent = 'hundred'
    thou = 'onethousand'

    length = 0
    aux = ''
    for number in range(1, 1000):
        t = number / 1000
        number -= t*1000
        c = number / 100
        number -= c*100
        d = number / 10
        number -= d*10
        u = number
        if c > 0: #'three hundred'
            aux += unit[c] + cent#+' '
            if d > 0 or u > 0: #' and '
                aux += 'and'
        if d > 1: #'forty'
            aux += dec[d]
        elif d == 1 and u > 0:
            aux += teens[d*10+u]
        elif d == 1:
            aux += dec[d]

        if u > 0 and d != 1:#'two'
            #if d > 0:#'-'
            #    aux += '-'
            aux += unit[u]
        length += len(aux)
        aux = ''
    length += len(aux + thou)
    print length


def problem_18():
    from numpy import array
    data = [[75],
    [95, 64],
    [17, 47, 82],
    [18, 35, 87, 10],
    [20, 4, 82, 47, 65],
    [19, 1, 23, 75, 3, 34],
    [88, 2, 77, 73, 7, 63, 67],
    [99, 65, 4, 28, 6, 16, 70, 92],
    [41, 41, 26, 56, 83, 40, 80, 70, 33],
    [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
    [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
    [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
    [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
    [63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
    [4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23]]

    leng = len(data)
    while leng-2 >= 0:
        cont = 0
        for p in data[leng-2]:
            if data[leng-1][cont] > data[leng-1][cont+1]:
                data[leng-2][cont] += data[leng-1][cont]
            else:
                data[leng-2][cont] += data[leng-1][cont+1]
            cont += 1
        del data[leng-1]
        leng = len(data)

    print data[0][0]


#n! means n  (n  1)  ...  3  2  1
#For example, 10! = 10  9  ...  3  2  1 = 3628800,
#and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
#Find the sum of the digits in the number 100!
def problem_20():
    fact = 1
    i = 1
    while( i < 100):
        i += 1
        fact *= i
        if fact % 10 == 0:
            fact /= 10
    sum = 0
    while fact > 0:
        sum += fact % 10
        fact /= 10
    print sum


def problem_21():
    limit = 10000
    number = 0
    sum = 0

    while number < limit:
        number += 1
        second = sum_divisors(number)
        if number != second and number < limit and second < limit:
            if sum_divisors( second ) == number:
                sum += number + second
    print sum/2


def problem_22():
    f = open("022.txt", "r").read()
    data = f.replace("\"", "").split(',')
    data.sort()
    sum = 0
    i = 0
    for p in data:
        i += 1
        temp = 0
        for q in p: #ord('A') == 65
            temp += ord(q)-64
        sum += temp*i
    print sum


def problem_24():
    #10! = 3628800
    #9! = 362880
    #725760 < 100000 < 3*9! ==> starts with 2
    from itertools import permutations
    temp = list( permutations([0, 1, 3, 4, 5, 6, 7, 8, 9]) )[999999-725760]
    exit = '2'
    for p in temp:
        exit += str(p)
    print exit



#The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases 
#by 3330, is unusual in two ways: (i) each of the three terms are prime, and, 
#(ii) each of the 4-digit numbers are permutations of one another.
#There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, 
#exhibiting this property, but there is one other 4-digit increasing sequence.
#What 12-digit number do you form by concatenating the three terms in this 
#sequence?
def tricompare(list):
    responses = []
    for p in list:
        for q in list:
            if q < p or (2*q-p) > 9999:
                continue
            try:
                list.index(2*q-p)
                if is_permutation(p, q) and is_permutation(q, 2*q-p):
                    responses.append( [p, q, 2*q-p] )
            except:
                pass
    return responses

def problem_49():
    prime_list = []
    for p in range(1001, 10000, 2):
        if is_prime(p):
            prime_list.append(p)
    aux = tricompare(prime_list)
    if aux != False:
        print aux

def prime_sum(list, ini, value):
    sum = 0
    cont = 0
    for p in list[ini:]:
        cont += 1
        if sum + p == value:
            return cont
        elif sum + p > value:
            return 0
        elif sum + p < value:
            sum = sum + p

def problem_50():
    prime_list = []
    for p in range(999999, 900000, -2):
        if is_prime(p):
            prime_list.append(p)
    prime_list.sort()
    prime_list.reverse()
    prime_fsum = []
    for p in range(2, 10000):
        if is_prime(p):
            prime_fsum.append(p)
    prime_fsum.sort()
    print 'prime lists stored'

    saida = {}
    for p in prime_list:
        for q in range(0, 100):
            num = prime_sum(prime_fsum, q, p)
            if num > 0:
                saida[str(num)] = p

    sai = saida.keys()
    sai.sort()
    print (sai[-1], saida[sai[-1]])

    
if __name__ == "__main__":
    problem_24()